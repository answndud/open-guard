import type { Finding } from "../scanner/types.js";
import type { RepoContext } from "../ingest/types.js";
import {
  ALWAYS_DENY_PATHS,
  SAFE_COMMANDS,
  SAFE_DOMAINS,
} from "./safe-lists.js";
import { ApprovalCategory, ApprovalMode } from "./types.js";
import type { Approvals, Policy, PolicyDefaults } from "./types.js";

export function generatePolicy(
  findings: readonly Finding[],
  context: RepoContext,
): Policy {
  const defaults: PolicyDefaults = {
    action: "deny",
    require_approval_for: [
      ApprovalCategory.ShellExec,
      ApprovalCategory.NewDomain,
      ApprovalCategory.CredentialPaths,
      ApprovalCategory.FileWrite,
      ApprovalCategory.ElevatedPrivilege,
    ],
  };

  const approvals: Approvals = {
    shell_exec: { mode: ApprovalMode.TwoStep, except_allowlisted: true },
    new_domain: { mode: ApprovalMode.Prompt, except_allowlisted: true },
    credential_paths: { mode: ApprovalMode.Deny, except_allowlisted: false },
    file_write: { mode: ApprovalMode.Auto, except_allowlisted: true },
    elevated_privilege: { mode: ApprovalMode.Deny, except_allowlisted: false },
  };

  const allow = {
    commands: SAFE_COMMANDS,
    paths: {
      read: ["./**", "~/.config/openguard/**", "/tmp/openguard-*/**"],
      write: ["./**", "/tmp/openguard-*/**"],
    },
    network: {
      domains: SAFE_DOMAINS,
      ports: [443, 80],
    },
  };

  const deny = {
    commands: [] as { cmd: string; args?: string[] }[],
    paths: ALWAYS_DENY_PATHS,
    network: {
      domains: [] as string[],
    },
  };

  const metadata = {
    name: context.repoUrl
      ? `openguard-policy-${safeName(context.repoUrl)}`
      : `openguard-policy-${safeName(context.rootPath)}`,
    description: "Generated by OpenGuard policy generator",
  };

  if (findings.length > 0) {
    deny.commands = findDeniedCommands(findings);
  }

  return {
    version: "v1",
    metadata,
    defaults,
    allow,
    deny,
    approvals,
  };
}

function findDeniedCommands(findings: readonly Finding[]) {
  const denied = new Map<string, { cmd: string; args?: string[] }>();
  for (const finding of findings) {
    if (finding.category !== "shell" && finding.category !== "obfuscation") {
      continue;
    }
    if (finding.severity !== "critical" && finding.severity !== "high") {
      continue;
    }
    const cmd = inferCommand(finding.evidence.match);
    if (!cmd) {
      continue;
    }
    if (!denied.has(cmd)) {
      denied.set(cmd, { cmd });
    }
  }

  return Array.from(denied.values());
}

function inferCommand(match: string): string | null {
  const trimmed = match.trim();
  if (!trimmed) {
    return null;
  }

  const token = trimmed.split(/\s+/)[0];
  if (!token) {
    return null;
  }

  return token.replace(/[^a-zA-Z0-9_-]/g, "");
}

function safeName(input: string): string {
  return input.replace(/[^a-zA-Z0-9-_]+/g, "-").slice(0, 48);
}
